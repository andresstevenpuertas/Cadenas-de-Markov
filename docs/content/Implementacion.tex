\section{Implementación}

\subsection{Modelo Hard-Core}

\begin{lstlisting}[language=Python]
def _actualizar_hardcore_vectorizado(config: np.ndarray,
                                     mask: np.ndarray) -> None:
    """
    Actualiza vertices del patron usando mascara.

    Args:
        config: Matriz KxK (modificada in-place)
        mask: Mascara booleana indicando que vertices actualizar
    """
    K = config.shape[0]

    # Vectorizar deteccion de vecinos ocupados
    vecinos_ocupados = np.zeros_like(config, dtype=bool)
    vecinos_ocupados[:-1, :] |= (config[1:, :] == 1)   # Abajo
    vecinos_ocupados[1:, :] |= (config[:-1, :] == 1)   # Arriba
    vecinos_ocupados[:, :-1] |= (config[:, 1:] == 1)   # Derecha
    vecinos_ocupados[:, 1:] |= (config[:, :-1] == 1)   # Izquierda

    # Aplicar mascara del patron bipartito
    update_positions = mask & ~vecinos_ocupados
    forced_zero = mask & vecinos_ocupados

    # Forzar a 0 donde hay vecinos
    config[forced_zero] = 0

    # Generar valores aleatorios solo donde es necesario
    num_updates = np.sum(update_positions)
    if num_updates > 0:
        config[update_positions] = np.random.randint(
            0, 2, size=num_updates, dtype=np.int8)
\end{lstlisting}

Esta función actualiza un subconjunto de vértices de la rejilla. Detecta vecinos ocupados en las cuatro direcciones cardinales, determina qué posiciones pueden actualizarse sin violar la restricción Hard-Core, y asigna valores aleatorios uniformemente entre 0 y 1 para las posiciones válidas.

\subsubsection{Gibbs Sampler}

\begin{lstlisting}[language=Python]
def gibbs_sampler_hardcore_optimizado(K: int, T: int,
                                      config_inicial: np.ndarray = None,
                                      guardar_historia: bool = True
                                      ) -> Tuple[np.ndarray,
                                                 List[np.ndarray]]:
    """
    Gibbs Sampler para el modelo Hard-Core.

    Args:
        K: Tamano de la rejilla (KxK)
        T: Numero de iteraciones
        config_inicial: Configuracion inicial (si None, vacia)
        guardar_historia: Si False, no guarda historia

    Returns:
        config_final: Configuracion final
        historia: Lista con configuraciones en puntos especificos
    """
    # Inicializar configuracion con dtype optimizado
    if config_inicial is None:
        config = np.zeros((K, K), dtype=np.int8)
    else:
        config = config_inicial.copy().astype(np.int8)

    # Crear mascaras de tablero de ajedrez (UNA VEZ)
    mask_blancas = np.zeros((K, K), dtype=bool)
    mask_blancas[::2, ::2] = True
    mask_blancas[1::2, 1::2] = True
    mask_negras = ~mask_blancas

    # Pre-computar puntos de guardado como set (O(1) lookup)
    historia = None
    if guardar_historia:
        puntos_guardado = {100, 1000, 5000, T}
        historia = [config.copy()]

    # Loop principal con actualizacion bipartita
    for t in range(1, T + 1):
        # Actualizar casillas blancas (sin conflictos)
        _actualizar_hardcore_vectorizado(config, mask_blancas)
        # Actualizar casillas negras (sin conflictos)
        _actualizar_hardcore_vectorizado(config, mask_negras)

        # Guardar historia solo en puntos especificos
        if guardar_historia and t in puntos_guardado:
            historia.append(config.copy())

    return config, historia
\end{lstlisting}

Esta función implementa el algoritmo Gibbs Sampler para generar configuraciones del modelo Hard-Core. Inicializa la rejilla en configuración vacía, ejecuta T iteraciones actualizando casillas negras, y guarda configuraciones en puntos específicos de tiempo para análisis de convergencia.

\subsubsection{Configuraciones factibles}

\begin{lstlisting}[language=Python]
def es_configuracion_factible_hardcore_vectorizada(
    config: np.ndarray) -> bool:
    """
    Verifica si configuracion es factible (vectorizada).

    Returns:
        True si es factible (sin particulas adyacentes)
    """
    particulas = (config == 1)

    # Detectar colisiones en todas las direcciones simultaneamente
    colisiones_h = particulas[:, :-1] & particulas[:, 1:]
    colisiones_v = particulas[:-1, :] & particulas[1:, :]

    return not (np.any(colisiones_h) or np.any(colisiones_v))
\end{lstlisting}

Esta función verifica si una configuración cumple con la restricción Hard-Core. Identifica todas las posiciones con partículas, detecta colisiones horizontales y verticales, y retorna \texttt{True} únicamente si no existe ningún par de partículas adyacentes.

\subsubsection{Generación Paralela de Muestras}

\begin{lstlisting}[language=Python]
def generar_muestras_hardcore_paralelo(K: int, T: int,
                                       num_muestras: int,
                                       base_seed: int = 42,
                                       n_jobs: int = None
                                       ) -> np.ndarray:
    """
    Genera multiples muestras en paralelo manteniendo
    reproducibilidad.

    Args:
        K, T: Parametros del sampler
        num_muestras: Numero de muestras a generar
        base_seed: Semilla base (se genera seed + i por muestra)
        n_jobs: Numero de workers (None = cpu_count - 1)

    Returns:
        Array con numero de particulas de cada muestra
    """
    if n_jobs is None:
        n_jobs = max(1, cpu_count() - 1)

    # Seeds deterministicas para reproducibilidad
    seeds = [base_seed + i for i in range(num_muestras)]
    args_list = [(seed, K, T) for seed in seeds]

    with Pool(processes=n_jobs) as pool:
        resultados = pool.map(
            _generar_muestra_hardcore_wrapper, args_list)

    return np.array(resultados)
\end{lstlisting}

Esta función genera múltiples configuraciones independientes del modelo Hard-Core ejecutándolas en paralelo. 

\subsection{Modelo q-Coloraciones - Implementación}

\subsubsection{Gibbs Sampler para Coloraciones}

\begin{lstlisting}[language=Python]
def gibbs_sampler_coloracion_optimizado(K: int, q: int, T: int,
                                        config_inicial: np.ndarray = None,
                                        guardar_historia: bool = True
                                        ) -> Tuple[np.ndarray,
                                                   List[np.ndarray]]:
    """
    Gibbs Sampler para q-coloraciones.

    Args:
        K: Tamano de la rejilla (KxK)
        q: Numero de colores disponibles
        T: Numero de iteraciones
        config_inicial: Configuracion inicial
        guardar_historia: Si True, guarda historia

    Returns:
        config_final: Configuracion final
        historia: Lista con configuraciones guardadas
    """
    # Inicializar con dtype optimizado
    if config_inicial is None:
        config = np.random.randint(0, q, size=(K, K),
                                   dtype=np.int8)
    else:
        config = config_inicial.copy().astype(np.int8)

    # Pre-computar puntos guardado
    historia = None
    if guardar_historia:
        puntos_guardado = {100, 1000, 5000, T}
        historia = [config.copy()]

    colores_vecinos = set()

    for t in range(1, T + 1):
        for i in range(K):
            for j in range(K):
                # Reutilizar set existente
                colores_vecinos.clear()

                if i > 0:
                    colores_vecinos.add(config[i-1, j])
                if i < K-1:
                    colores_vecinos.add(config[i+1, j])
                if j > 0:
                    colores_vecinos.add(config[i, j-1])
                if j < K-1:
                    colores_vecinos.add(config[i, j+1])

                # Calcular colores validos
                if len(colores_vecinos) < q:
                    colores_validos = [c for c in range(q)
                                      if c not in colores_vecinos]
                    idx = np.random.randint(0, len(colores_validos))
                    config[i, j] = colores_validos[idx]

        if guardar_historia and t in puntos_guardado:
            historia.append(config.copy())

    return config, historia
\end{lstlisting}

Esta función implementa el algoritmo Gibbs Sampler para generar q-coloraciones propias. Inicializa la rejilla con colores aleatorios.

\subsubsection{Coloraciones factibles}

\begin{lstlisting}[language=Python]
def es_coloracion_propia_vectorizada(config: np.ndarray) -> bool:
    """
    Verifica si coloracion es propia (vectorizada).

    Returns:
        True si vertices adyacentes tienen colores distintos
    """
    colision_h = (config[:, :-1] == config[:, 1:])
    colision_v = (config[:-1, :] == config[1:, :])
    return not (np.any(colision_h) or np.any(colision_v))
\end{lstlisting}

Esta función verifica si una coloración es propia. Compara colores de celdas adyacentes horizontalmente y verticalmente, detecta cualquier par de vértices adyacentes con el mismo color, y retorna \texttt{True} únicamente si todos los vértices adyacentes tienen colores diferentes.

\subsubsection{Generación Paralela de Coloraciones}

\begin{lstlisting}[language=Python]
def generar_muestras_coloracion_paralelo(K: int, q: int, T: int,
                                         num_muestras: int,
                                         base_seed: int = 42,
                                         n_jobs: int = None
                                         ) -> np.ndarray:
    """
    Genera multiples muestras de q-coloraciones en paralelo.
    """
    if n_jobs is None:
        n_jobs = max(1, cpu_count() - 1)

    seeds = [base_seed + i for i in range(num_muestras)]
    args_list = [(seed, K, q, T) for seed in seeds]

    with Pool(processes=n_jobs) as pool:
        configs = pool.map(
            _generar_muestra_coloracion_wrapper, args_list)

    return np.array(configs)
\end{lstlisting}

Esta función genera múltiples q-coloraciones en paralelo.
